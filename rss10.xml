<?xml version="1.0"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Planet SymPy</title>
    <link>http://planet.sympy.org/</link>
    <language>en</language>
    <description>Planet SymPy - http://planet.sympy.org/</description>
    <atom:link href="http://planet.sympy.org/rss10.xml" rel="self" type="application/rss+xml"/>
    <item>
      <guid isPermaLink="false">https://asmeurer.com/blog/posts/quansight-labs-work-update-for-september-2019/</guid>
      <author>Aaron Meurer (asmeurer)</author>
      <title>Aaron Meurer (asmeurer): Quansight Labs Work Update for September, 2019</title>
      <pubDate>Mon, 07 Oct 2019 05:00:00 GMT</pubDate>
      <link>https://asmeurer.com/blog/posts/quansight-labs-work-update-for-september-2019/</link>
      <description>&lt;div&gt;&lt;p&gt;&lt;em&gt;This post has been cross-posted on the &lt;a href="https://labs.quansight.org/blog/2019/10/quansight-labs-work-update-for-september-2019/"&gt;Quansight Labs
Blog&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As of November, 2018, I have been working at
&lt;a href="https://www.quansight.com/"&gt;Quansight&lt;/a&gt;. Quansight is a new startup founded by
the same people who started Anaconda, which aims to connect companies and open
source communities, and offers consulting, training, support and mentoring
services. I work under the heading of &lt;a href="https://www.quansight.com/labs"&gt;Quansight
Labs&lt;/a&gt;. Quansight Labs is a public-benefit
division of Quansight. It provides a home for a "PyData Core Team" which
consists of developers, community managers, designers, and documentation
writers who build open-source technology and grow open-source communities
around all aspects of the AI and Data Science workflow.&lt;/p&gt;
&lt;p&gt;My work at Quansight is split between doing open source consulting for various
companies, and working on SymPy.
&lt;a href="https://www.sympy.org/en/index.html"&gt;SymPy&lt;/a&gt;, for those who do not know, is a
symbolic mathematics library written in pure Python. I am the lead maintainer
of SymPy.&lt;/p&gt;
&lt;p&gt;In this post, I will detail some of the open source work that I have done
recently, both as part of my open source consulting, and as part of my work on
SymPy for Quansight Labs.&lt;/p&gt;
&lt;h3&gt;Bounds Checking in Numba&lt;/h3&gt;
&lt;p&gt;As part of work on a client project, I have been working on contributing code
to the &lt;a href="https://numba.pydata.org"&gt;numba&lt;/a&gt; project. Numba is a just-in-time
compiler for Python. It lets you write native Python code and with the use of
a simple &lt;code&gt;@jit&lt;/code&gt; decorator, the code will be automatically sped up using LLVM.
This can result in code that is up to 1000x faster in some cases:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
In [1]: import numba

In [2]: import numpy

In [3]: def test(x):
   ...:     A = 0
   ...:     for i in range(len(x)):
   ...:         A += i*x[i]
   ...:     return A
   ...:

In [4]: @numba.njit
   ...: def test_jit(x):
   ...:     A = 0
   ...:     for i in range(len(x)):
   ...:         A += i*x[i]
   ...:     return A
   ...:

In [5]: x = numpy.arange(1000)

In [6]: %timeit test(x)
249 &amp;#181;s &amp;#177; 5.77 &amp;#181;s per loop (mean &amp;#177; std. dev. of 7 runs, 1000 loops each)

In [7]: %timeit test_jit(x)
336 ns &amp;#177; 0.638 ns per loop (mean &amp;#177; std. dev. of 7 runs, 1000000 loops each)

In [8]: 249/.336
Out[8]: 741.0714285714286
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Numba only works for a subset of Python code, and primarily targets code that
uses NumPy arrays.&lt;/p&gt;
&lt;p&gt;Numba, with the help of LLVM, achieves this level of performance through many
optimizations. One thing that it does to improve performance is to remove all
bounds checking from array indexing. This means that if an array index is out
of bounds, instead of receiving an &lt;code&gt;IndexError&lt;/code&gt;, you will get garbage, or
possibly a segmentation fault.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import numpy as np
&amp;gt;&amp;gt;&amp;gt; from numba import njit
&amp;gt;&amp;gt;&amp;gt; def outtabounds(x):
...     A = 0
...     for i in range(1000):
...         A += x[i]
...     return A
&amp;gt;&amp;gt;&amp;gt; x = np.arange(100)
&amp;gt;&amp;gt;&amp;gt; outtabounds(x) # pure Python/NumPy behavior
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
  File "&amp;lt;stdin&amp;gt;", line 4, in outtabounds
IndexError: index 100 is out of bounds for axis 0 with size 100
&amp;gt;&amp;gt;&amp;gt; njit(outtabounds)(x) # the default numba behavior
-8557904790533229732
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In numba pull request &lt;a href="https://github.com/numba/numba/pull/4432"&gt;#4432&lt;/a&gt;, I am
working on adding a flag to &lt;code&gt;@njit&lt;/code&gt; that will enable bounds checks for array
indexing. This will remain disabled by default for performance purposes. But
you will be able to enable it by passing &lt;code&gt;boundscheck=True&lt;/code&gt; to &lt;code&gt;@njit&lt;/code&gt;, or by
setting the &lt;code&gt;NUMBA_BOUNDSCHECK=1&lt;/code&gt; environment variable. This will make it
easier to detect out of bounds issues like the one above. It will work like&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-pycon"&gt;&amp;gt;&amp;gt;&amp;gt; @njit(boundscheck=True)
... def outtabounds(x):
...     A = 0
...     for i in range(1000):
...         A += x[i]
...     return A
&amp;gt;&amp;gt;&amp;gt; x = np.arange(100)
&amp;gt;&amp;gt;&amp;gt; outtabounds(x) # numba behavior in my pull request #4432
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
IndexError: index is out of bounds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The pull request is still in progress, and many things such as the quality of
the error message reporting will need to be improved. This should make
debugging issues easier for people who write numba code once it is merged.&lt;/p&gt;
&lt;h3&gt;removestar&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.asmeurer.com/removestar/"&gt;removestar&lt;/a&gt; is a new tool I wrote to
automatically replace &lt;code&gt;import *&lt;/code&gt; in Python modules with explicit imports.&lt;/p&gt;
&lt;p&gt;For those who don't know, Python's &lt;code&gt;import&lt;/code&gt; statement supports so-called
"wildcard" or "star" imports, like&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;from sympy import *
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will import every public name from the &lt;code&gt;sympy&lt;/code&gt; module into the current
namespace. This is often useful because it saves on typing every name that is
used in the import line. This is especially useful when working interactively,
where you just want to import every name and minimize typing.&lt;/p&gt;
&lt;p&gt;However, doing &lt;code&gt;from module import *&lt;/code&gt; is generally frowned upon in Python. It is
considered acceptable when working interactively at a &lt;code&gt;python&lt;/code&gt; prompt, or in
&lt;code&gt;__init__.py&lt;/code&gt; files (removestar skips &lt;code&gt;__init__.py&lt;/code&gt; files by default).&lt;/p&gt;
&lt;p&gt;Some reasons why &lt;code&gt;import *&lt;/code&gt; is bad:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It hides which names are actually imported.&lt;/li&gt;
&lt;li&gt;It is difficult both for human readers and static analyzers such as
pyflakes to tell where a given name comes from when &lt;code&gt;import *&lt;/code&gt; is used. For
example, pyflakes cannot detect unused names (for instance, from typos) in
the presence of &lt;code&gt;import *&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If there are multiple &lt;code&gt;import *&lt;/code&gt; statements, it may not be clear which names
come from which module. In some cases, both modules may have a given name,
but only the second import will end up being used. This can break people's
intuition that the order of imports in a Python file generally does not
matter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import *&lt;/code&gt; often imports more names than you would expect. Unless the module
you import defines &lt;code&gt;__all__&lt;/code&gt; or carefully &lt;code&gt;del&lt;/code&gt;s unused names at the module
level, &lt;code&gt;import *&lt;/code&gt; will import every public (doesn't start with an
underscore) name defined in the module file. This can often include things
like standard library imports or loop variables defined at the top-level of
the file. For imports from modules (from &lt;code&gt;__init__.py&lt;/code&gt;), &lt;code&gt;from module import *&lt;/code&gt; will include every submodule defined in that module. Using &lt;code&gt;__all__&lt;/code&gt; in
modules and &lt;code&gt;__init__.py&lt;/code&gt; files is also good practice, as these things are
also often confusing even for interactive use where &lt;code&gt;import *&lt;/code&gt; is
acceptable.&lt;/li&gt;
&lt;li&gt;In Python 3, &lt;code&gt;import *&lt;/code&gt; is syntactically not allowed inside of a function
definition.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here are some official Python references stating not to use &lt;code&gt;import *&lt;/code&gt; in
files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3/faq/programming.html?highlight=faq#what-are-the-best-practices-for-using-import-in-a-module"&gt;The official Python
FAQ&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In general, don&amp;#8217;t use &lt;code&gt;from modulename import *&lt;/code&gt;. Doing so clutters the
importer&amp;#8217;s namespace, and makes it much harder for linters to detect
undefined names.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0008/#imports"&gt;PEP 8&lt;/a&gt; (the official
Python style guide):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Wildcard imports (&lt;code&gt;from &amp;lt;module&amp;gt; import *&lt;/code&gt;) should be avoided, as they
make it unclear which names are present in the namespace, confusing both
readers and many automated tools.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unfortunately, if you come across a file in the wild that uses &lt;code&gt;import *&lt;/code&gt;, it
can be hard to fix it, because you need to find every name in the file that is
imported from the &lt;code&gt;*&lt;/code&gt; and manually add an import for it. Removestar makes this
easy by finding which names come from &lt;code&gt;*&lt;/code&gt; imports and replacing the import
lines in the file automatically.&lt;/p&gt;
&lt;p&gt;As an example, suppose you have a module &lt;code&gt;mymod&lt;/code&gt; like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mymod/
  | __init__.py
  | a.py
  | b.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;with&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;# mymod/a.py
from .b import *

def func(x):
    return x + y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;# mymod/b.py
x = 1
y = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then &lt;code&gt;removestar&lt;/code&gt; works like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ removestar -i mymod/
$ cat mymod/a.py
# mymod/a.py
from .b import y

def func(x):
    return x + y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;-i&lt;/code&gt; flag causes it to edit &lt;code&gt;a.py&lt;/code&gt; in-place. Without it, it would just
print a diff to the terminal.&lt;/p&gt;
&lt;p&gt;For implicit star imports and explicit star imports from the same module,
&lt;code&gt;removestar&lt;/code&gt; works statically, making use of
&lt;a href="https://github.com/PyCQA/pyflakes"&gt;pyflakes&lt;/a&gt;. This means none of the code is
actually executed. For external imports, it is not possible to work statically
as external imports may include C extension modules, so in that case, it
imports the names dynamically.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;removestar&lt;/code&gt; can be installed with pip or conda:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install removestar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or if you use conda&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda install -c conda-forge removestar
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;sphinx-math-dollar&lt;/h3&gt;
&lt;p&gt;In SymPy, we make heavy use of LaTeX math in our documentation. For example,
in our &lt;a href="https://docs.sympy.org/dev/modules/functions/special.html#sympy.functions.special.hyper.hyper"&gt;special functions
documentation&lt;/a&gt;,
most special functions are defined using a LaTeX formula, like &lt;img alt="The docs for besselj" src="https://asmeurer.com/blog/besselj_docs.png" /&gt;&lt;/p&gt;
&lt;p&gt;(from &lt;a href="https://docs.sympy.org/dev/modules/functions/special.html#sympy.functions.special.bessel.besselj"&gt;https://docs.sympy.org/dev/modules/functions/special.html#sympy.functions.special.bessel.besselj&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;However, the source for this math in the docstring of the function uses RST
syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;class besselj(BesselBase):
    """
    Bessel function of the first kind.

    The Bessel `J` function of order `\nu` is defined to be the function
    satisfying Bessel's differential equation

    .. math ::
        z^2 \frac{\mathrm{d}^2 w}{\mathrm{d}z^2}
        + z \frac{\mathrm{d}w}{\mathrm{d}z} + (z^2 - \nu^2) w = 0,

    with Laurent expansion

    .. math ::
        J_\nu(z) = z^\nu \left(\frac{1}{\Gamma(\nu + 1) 2^\nu} + O(z^2) \right),

    if :math:`\nu` is not a negative integer. If :math:`\nu=-n \in \mathbb{Z}_{&amp;lt;0}`
    *is* a negative integer, then the definition is

    .. math ::
        J_{-n}(z) = (-1)^n J_n(z).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Furthermore, in SymPy's documentation we have configured it so that text
between `single backticks` is rendered as math. This was originally done for
convenience, as the alternative way is to write &lt;code&gt;:math:`\nu`&lt;/code&gt; every
time you want to use inline math. But this has lead to many people being
confused, as they are used to Markdown where `single backticks` produce
&lt;code&gt;code&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A better way to write this would be if we could delimit math with dollar
signs, like &lt;code&gt;$\nu$&lt;/code&gt;. This is how things are done in LaTeX documents, as well
as in things like the Jupyter notebook.&lt;/p&gt;
&lt;p&gt;With the new &lt;a href="https://www.sympy.org/sphinx-math-dollar/"&gt;sphinx-math-dollar&lt;/a&gt;
Sphinx extension, this is now possible. Writing &lt;code&gt;$\nu$&lt;/code&gt; produces $\nu$, and
the above docstring can now be written as&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;class besselj(BesselBase):
    """
    Bessel function of the first kind.

    The Bessel $J$ function of order $\nu$ is defined to be the function
    satisfying Bessel's differential equation

    .. math ::
        z^2 \frac{\mathrm{d}^2 w}{\mathrm{d}z^2}
        + z \frac{\mathrm{d}w}{\mathrm{d}z} + (z^2 - \nu^2) w = 0,

    with Laurent expansion

    .. math ::
        J_\nu(z) = z^\nu \left(\frac{1}{\Gamma(\nu + 1) 2^\nu} + O(z^2) \right),

    if $\nu$ is not a negative integer. If $\nu=-n \in \mathbb{Z}_{&amp;lt;0}$
    *is* a negative integer, then the definition is

    .. math ::
        J_{-n}(z) = (-1)^n J_n(z).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also plan to add support for &lt;code&gt;$$double dollars$$&lt;/code&gt; for display math so that &lt;code&gt;.. math ::&lt;/code&gt; is no longer needed either .&lt;/p&gt;
&lt;p&gt;For end users, the documentation on &lt;a href="https://docs.sympy.org"&gt;docs.sympy.org&lt;/a&gt;
will continue to render exactly the same, but for developers, it is much
easier to read and write.&lt;/p&gt;
&lt;p&gt;This extension can be easily used in any Sphinx project. Simply install it
with pip or conda:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install sphinx-math-dollar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda install -c conda-forge sphinx-math-dollar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then enable it in your &lt;code&gt;conf.py&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-py"&gt;extensions = ['sphinx_math_dollar', 'sphinx.ext.mathjax']
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Google Season of Docs&lt;/h3&gt;
&lt;p&gt;The above work on sphinx-math-dollar is part of work I have been doing to
improve the tooling around SymPy's documentation. This has been to assist our
technical writer Lauren Glattly, who is working with SymPy for the next three
months as part of the new &lt;a href="https://developers.google.com/season-of-docs/"&gt;Google Season of
Docs&lt;/a&gt; program. Lauren's project
is to improve the consistency of our docstrings in SymPy. She has already
identified many key ways our docstring documentation can be improved, and is
currently working on a style guide for writing docstrings. Some of the issues
that Lauren has identified require improved tooling around the way the HTML
documentation is built to fix. So some other SymPy developers and I have been
working on improving this, so that she can focus on the technical writing
aspects of our documentation.&lt;/p&gt;
&lt;p&gt;Lauren has created a draft style guide for documentation at
&lt;a href="https://github.com/sympy/sympy/wiki/SymPy-Documentation-Style-Guide"&gt;https://github.com/sympy/sympy/wiki/SymPy-Documentation-Style-Guide&lt;/a&gt;. Please
take a moment to look at it and if you have any feedback on it, comment below
or write to the SymPy mailing list.&lt;/p&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/08/week-12-the-final-week/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 12: The Final Week</title>
      <pubDate>Fri, 23 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/08/week-12-the-final-week/</link>
      <description>&lt;p&gt;&amp;#8220;Software is like entropy: It is difficult to grasp, weighs nothing, and obeys the Second Law of Thermodynamics; i.e., it always increases.&amp;#8221;  &amp;#8212; Norman Augustine
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week will be the last week of coding for GSoC 2019. It is time to finish work now.
 The C Parser Travis Build Tests Documentation  The C Parser I completed the C Parser last week along with the documentation for the module.</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/08/week-11-the-other-parser/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 11: The Other Parser</title>
      <pubDate>Thu, 22 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/08/week-11-the-other-parser/</link>
      <description>&lt;p&gt;Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this week we&amp;rsquo;re talking about the C parser.
 The Fortran Parser The C Parser Documentation Travis Build  The Fortran Parser The Fortran Parser is complete. The Pull Request has also been merged. The parser is merged in master and will be a part of the next SymPy release. You can check out the source code for the Parser at the Pull Request.</description>
    </item>
    <item>
      <guid isPermaLink="false">http://shubhamjha.com/2019/08/21/GSoC-Week-12-(The-Final-Week)</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 12 (The Final Week)</title>
      <pubDate>Wed, 21 Aug 2019 00:00:00 GMT</pubDate>
      <link>http://shubhamjha.com/2019/08/21/GSoC-Week-12-(The-Final-Week).html</link>
      <description>&lt;p&gt;The last week of coding period is officially over. A summary of the work done during this week is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/17379"&gt;#17379&lt;/a&gt; is now complete and currently under review. I will try to get it merged within this week.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/17392"&gt;#17392&lt;/a&gt; still needs work. I will try to put a closure to this by the end of week.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/17440"&gt;#17440&lt;/a&gt; was started. It attempts to add a powerful (but optional) SAT solving engine to SymPy (&lt;a href="https://pypi.org/project/pycosat/"&gt;pycosat&lt;/a&gt;). The performance gain for SAT solver is also subtle here: Using this
    &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;from sympy import *
from sympy.abc import x
r = random_poly(x, 100, -100, 100)
ans = ask(Q.positive(r), Q.positive(x))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;The performance is like&lt;/p&gt;
    &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;# In master
 |  `- 0.631 check_satisfiability  sympy/assumptions/satask.py:30
 |     `- 0.607 satisfiable  sympy/logic/inference.py:38
 |        `- 0.607 dpll_satisfiable  sympy/logic/algorithms/dpll2.py:21
# With pycosat
 |  `- 0.122 check_satisfiability  sympy/assumptions/satask.py:30
 |     `- 0.098 satisfiable  sympy/logic/inference.py:39
 |        `- 0.096 pycosat_satisfiable  sympy/logic/algorithms/pycosat_wrapper.py:11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;It is finished and under review now.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also, with the end of GSoC 2019, final evaluations have started. I will be writing a final report to the whole project by the end of this week.&lt;/p&gt;

&lt;p&gt;So far it has been a great and enriching experience for me. It was my first attempt at GSoC and I am lucky to get such an exposure. I acknowledge that I started with an abstract idea of the project but I now understand both the need and the code of &lt;code class="highlighter-rouge"&gt;New Assumptions&lt;/code&gt; pretty well (thanks to &lt;a href="https://github.com/asmeurer"&gt;Aaron&lt;/a&gt; who wrote the most of it). The system is still in its early phases and needs a lot more work. I am happy to be a part of it and I will be available to work on it.&lt;/p&gt;

&lt;p&gt;This is the last weekly report but I will still be contributing to SymPy and open source in general. I will try to write more of such experiences through this portal. Till then, Good bye and thank you!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=113</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-12 &#x2013; The Final wrap-up</title>
      <pubDate>Tue, 20 Aug 2019 17:10:27 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/08/20/gsoc19-week-12-the-final-wrap-up/</link>
      <description>&lt;p&gt;This was the last week of the coding
period. With not much of work left, the goal was to wrap-up the PR&amp;#8217;s.&lt;/p&gt;



&lt;p&gt;The week started with the merge of &amp;nbsp;&lt;a href="https://github.com/sympy/sympy/pull/17001"&gt;PR #17001&lt;/a&gt; which implemented a method &lt;strong&gt;cut_section()&lt;/strong&gt; in the polygon class, in order to get two new polygons when a polygon is cut via a line. After this a new method &lt;strong&gt;first_moment_of_area()&lt;/strong&gt; was added in &lt;a href="https://github.com/sympy/sympy/pull/17153"&gt;PR #17153&lt;/a&gt;. This method used &lt;strong&gt;cut_section()&lt;/strong&gt; for its implementation. Tests for the same were added in this PR. Also the existing documentation was improved. I also renamed the &lt;strong&gt;polar_modulus()&lt;/strong&gt; function to &lt;strong&gt;polar_second_moment_of_area() &lt;/strong&gt;which was a more general term as compared to the previous name. This PR also got &lt;strong&gt;merged&lt;/strong&gt; later on.&lt;/p&gt;



&lt;p&gt;Now, we are left with two more PR&amp;#8217;s to go.
&lt;a href="https://github.com/sympy/sympy/pull/17122"&gt;PR #17122&lt;/a&gt; (Column
Buckling) and &lt;a href="https://github.com/sympy/sympy/pull/17345"&gt;PR #17345&lt;/a&gt;
(Beam diagram). The column buckling probably requires a little more
documentation. I will surely look into it and add some more explanations and references
to it. Also, the beam diagram PR has been completed and documented. A few more
discussions to be done on its working and we will be ready with it.&lt;span id="more-113"&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;I believe that by the end of this week
both of these will finally get a merge.&lt;/p&gt;



&lt;p&gt;Another task that remains is the implementation of the &lt;a href="https://github.com/sympy/sympy/issues/17302"&gt;Truss class&lt;/a&gt;. Some rigorous debate and discussion is still needed to be done before we start its implementation. Once we agree on the implementation needs and API it won&amp;#8217;t be a difficult task to write it through.&lt;/p&gt;



&lt;p&gt;Also, since the final evaluations have
started I will be writing the project report which I have to submit before the
next week ends.&lt;/p&gt;



&lt;p&gt;Since officially the coding period ends here, there would be no ToDo&amp;#8217;s for the next week, just the final wrapping up and will surely try to complete the work that is still left.&lt;/p&gt;



&lt;p&gt;Will keep you updated!&lt;/p&gt;



&lt;p&gt;Thanks! &lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-08-20-gsoc-week12/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 12 !!</title>
      <pubDate>Tue, 20 Aug 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-08-20-gsoc-week12/</link>
      <description>&lt;p&gt;Week 12 ends.. - 
          So, finally after a long summer GSoC has come to an end!! It has been a great experience, and something which I will cherish for the rest of my life. I would like to thank my mentor Sartaj, who has been guiding me through the thick and thin of times....</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_12</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 12 - Ending GSoC 2019</title>
      <pubDate>Tue, 20 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_12/</link>
      <description>&lt;p&gt;As the title suggests, with the third phase, the journey of my GSoC 2019 comes to an end. It was full of challanges, learning experiences, and above all interaction with the open source community of &lt;code class="highlighter-rouge"&gt;SymPy&lt;/code&gt;.&lt;br /&gt;
In this blog post I will share with you the work done between phase 2 and phase 3, in terms of PRs, merged and open.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Merged&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17174"&gt;#17174&lt;/a&gt; : In this PR, Gaussian ensembles were added to &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17304"&gt;#17304&lt;/a&gt; : While working on the above PR, I got an idea to open this one to add cicular ensembles to &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt;. I learned a lot about Haar measure while working on this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17306"&gt;#17306&lt;/a&gt;: This PR added matrices with random expressions. The challenging part of this PR was to generate canonical results for passing the tests.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17336"&gt;#17336&lt;/a&gt; : This was related to bug fix in &lt;code class="highlighter-rouge"&gt;Q.ask&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Matrix&lt;/code&gt;. Take a look at an example &lt;a href="https://github.com/sympy/sympy/pull/17336#issue-304058013"&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Open&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17387"&gt;#17387&lt;/a&gt; : This PR aims to add support for assumptions of dependence among random variables, like, &lt;code class="highlighter-rouge"&gt;Covariance&lt;/code&gt;, etc.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17146"&gt;#17146&lt;/a&gt; : This PR is in its last stages to fix and upgrade the &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; set and we are finalizing few things, like changes in the output of &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;. As planned I was successful at writing exhaustive and systematic tests.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Well, now, time to say good bye! It was a nice experience writing about journey in this blog. If you have read this from the beginning then thanks a lot buddy, and I wish for your acceptance in GSoC 2020. Keep Open Sourcing :D&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/z_final_report</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Final Report</title>
      <pubDate>Tue, 20 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/z_final_report/</link>
      <description>&lt;p&gt;This report summarizes the work done in my GSoC 2019 project, &lt;strong&gt;Enhancement of Statistics Module&lt;/strong&gt; wth SymPy. A step by step development of the project is available at &lt;a href="https://czgdp1807.github.io"&gt;czgdp1807.github.io&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;About Me&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I am a third year Bachelor of Technology student at Indian Institute of Technology, Jodhpur in the department of Computer Science and Engineering.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Project Outline&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The project plan was focused on the following areas of statistics that were required to be added to &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Community Bonding&lt;/strong&gt; - I was supposed to add, Dirichlet Distribution, Multivariate Ewens Distribution, Multinomial Distribution, Negative multinomial distribution, and Generalized multivariate log-gamma distribution to &lt;code class="highlighter-rouge"&gt;sympy.stats.joint_rv_types&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Phase 1&lt;/strong&gt; - I was supposed to work on stochastic processes, primraly on Markov chains, including it&amp;#8217;s API design, algorithm and implementation.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Phase 2&lt;/strong&gt; - I was expected to work on random matrices, including Gaussian ensembles and matrices with random expressions as their elements.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Phase 3&lt;/strong&gt; - I planned to work on assumptions of dependence, improving result generation by &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt; and improving other modules so that &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt; can function properly.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Pull Requests&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This section describes the actual work done during the coding period in terms of merged PRs.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Community Bonding&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16576"&gt;#16576&lt;/a&gt;: This PR added &lt;code class="highlighter-rouge"&gt;Dirichlet&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;MultivariteEwens&lt;/code&gt; distributions.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16808"&gt;#16808&lt;/a&gt; : This PR added &lt;code class="highlighter-rouge"&gt;Multinomial&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;NegativeMultinomial&lt;/code&gt; distribution.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16810"&gt;#16810&lt;/a&gt; : This PR improved the API of &lt;code class="highlighter-rouge"&gt;Sum&lt;/code&gt; by allowing &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; as the limits.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16825"&gt;#16825&lt;/a&gt; : This PR in continuation, added &lt;code class="highlighter-rouge"&gt;GeneralizedMultivariateLogGamma&lt;/code&gt; distribution. This was an interesting one due to the complexity involved in its PDF.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16834"&gt;#16834&lt;/a&gt; : This PR enhanced the &lt;code class="highlighter-rouge"&gt;Multinomial&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;NegativeMultinomial&lt;/code&gt; distributions by allowing symbolic dimensions for them.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Phase 1&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16897"&gt;#16897&lt;/a&gt; : This was related to &lt;code class="highlighter-rouge"&gt;sympy.core&lt;/code&gt; and it helped in removing disparity in the results of special function &lt;code class="highlighter-rouge"&gt;gamma&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16908"&gt;#16908&lt;/a&gt; : This PR improved &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt; by allowing conditions with foriegn symbols.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16913"&gt;#16913&lt;/a&gt; : This removed the unreachable code from &lt;code class="highlighter-rouge"&gt;sympy.stats.frv&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16914"&gt;#16914&lt;/a&gt; : This PR allowed symbolic dimensions to &lt;code class="highlighter-rouge"&gt;MultivariateEwens&lt;/code&gt; distribution.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16929"&gt;#16929&lt;/a&gt; : This one was for the &lt;code class="highlighter-rouge"&gt;sympy.tensor&lt;/code&gt; module. It optimized the &lt;code class="highlighter-rouge"&gt;ArrayComprehension&lt;/code&gt; and covered some corner cases.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16981"&gt;#16981&lt;/a&gt; : This PR added the architecture of stochastic processes. It also added discrete Markov chain to &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17030"&gt;#17030&lt;/a&gt; : Some features like, &lt;code class="highlighter-rouge"&gt;joint_dsitribution&lt;/code&gt; were added to stochastic processes in this PR.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17046"&gt;#17046&lt;/a&gt; : Some common properties of discrete Markov chains, like fundamental matrix, fixed row vector were added.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Phase 2&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16934"&gt;#16934&lt;/a&gt; : The bug fixes for &lt;code class="highlighter-rouge"&gt;sympy.stats.joint_rv_types&lt;/code&gt; were complete and the further work has been handed over to my co-student, Ritesh.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16962"&gt;#16962&lt;/a&gt; : This was continuation of the work done in phase 1 for allowing symbolic dimensions in finite random variables. As I planned, this PR got merged in phase 2, after some changes.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17083"&gt;#17083&lt;/a&gt;: The work done in this PR framed the platform and reason for the next one. The algorithm that got merged was a bit difficult to extend, and maintain. Thanks to Francesco for his &lt;a href="https://github.com/sympy/sympy/pull/17083#issuecomment-508256359"&gt;comment&lt;/a&gt; for motivating me to re-think the whole framework.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17163"&gt;#17163&lt;/a&gt; : This was one of the most challenging PRs of the project, because, it involved re-designing the algorithm, refactoring the code and moreover lot of thinking. The details can be found at &lt;a href="https://github.com/sympy/sympy/pull/17163#issuecomment-510939984"&gt;this comment&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Phase 3&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17174"&gt;#17174&lt;/a&gt; : In this PR, Gaussian ensembles were added to &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17304"&gt;#17304&lt;/a&gt; : While working on the above PR, I got an idea to open this one to add cicular ensembles to &lt;code class="highlighter-rouge"&gt;sympy.stats&lt;/code&gt;. I learned a lot about Haar measure while working.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17306"&gt;#17306&lt;/a&gt;: This PR added matrices with random expressions. The challenging part of this PR was to generate canonical results for passing the tests.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17336"&gt;#17336&lt;/a&gt; : This was related to bug fix in &lt;code class="highlighter-rouge"&gt;Q.ask&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Matrix&lt;/code&gt;. Take a look at an example &lt;a href="https://github.com/sympy/sympy/pull/17336#issue-304058013"&gt;here&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Miscellaneous Work&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This section contains some of my PRs related to miscellanous issues like, workflow improvement, etc.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16899"&gt;#16899&lt;/a&gt; : This was a workflow related to PR to ignore the &lt;code class="highlighter-rouge"&gt;.vscode&lt;/code&gt; folder.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17003"&gt;#17003&lt;/a&gt; : This PR ignored the &lt;code class="highlighter-rouge"&gt;__pycahce__&lt;/code&gt; folder by adding it &lt;code class="highlighter-rouge"&gt;.gitignore&lt;/code&gt; file.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Future Work&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The following PRs are open and are in their last stages for merging. Any interested student can take a look at them to extend my work in his/her GSoC project.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17387"&gt;#17387&lt;/a&gt; : This PR aims to add support for assumptions of dependence among random variables, like, &lt;code class="highlighter-rouge"&gt;Covariance&lt;/code&gt;, etc.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17146"&gt;#17146&lt;/a&gt; : This PR is in its last stages to fix and upgrade the &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; set and we are finalizing few things, like changes in the output of &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;. As planned I was successful at writing exhaustive and systematic tests.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apart from the above, work on densities of Circular ensembles remains to be done. One can read the Theorem 3, page 8 of &lt;a href="https://arxiv.org/pdf/1103.3408.pdf"&gt;this paper&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-12</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 11 and 12 - Phase-III Completion</title>
      <pubDate>Mon, 19 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-12</link>
      <description>&lt;p&gt;We&amp;#8217;ve reached to the end of GSoC 2019, end to the really productive and wonderful summer. In the last two weeks I worked on documenting polycyclic groups which got merged as well, here is the PR &lt;a href="https://github.com/sympy/sympy/pull/17399"&gt;sympy/sympy#17399&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also, the PR on Induced-pcgs and exponent vector for polycyclic subgroups got merged &lt;a href="https://github.com/sympy/sympy/pull/17317"&gt;sympy/sympy#17317&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s have a look at some of the highlights of documentation.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The parameters of both the classes(&lt;code class="highlighter-rouge"&gt;PolycyclicGroup&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;Collector&lt;/code&gt;) has been discussed in detail.&lt;/li&gt;
  &lt;li&gt;Conditions for a word to be collected or uncollected is highlighted.&lt;/li&gt;
  &lt;li&gt;Computation of polycyclic presentation has been explained in detail highlighting the sequence in which presentation is computed with the corresponding pcgs and and polycyclic series elements used.&lt;/li&gt;
  &lt;li&gt;Other methods like &lt;code class="highlighter-rouge"&gt;subword_index&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;exponent_vector&lt;/code&gt;, &lt;code class="highlighter-rouge"&gt;depth&lt;/code&gt;, etc are also documented.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An example is provided for every functionality.
For more details one can visit:
&lt;a href="https://docs.sympy.org/dev/modules/combinatorics/pc_groups.html"&gt;https://docs.sympy.org/dev/modules/combinatorics/pc_groups.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now, I&amp;#8217;m supposed to prepare a final report presenting all the work done. Will update with report next week.
In addition to the report preparation I&amp;#8217;ll try to add &lt;code class="highlighter-rouge"&gt;Parameters&lt;/code&gt; section in the &lt;code class="highlighter-rouge"&gt;docstrings&lt;/code&gt; for various classes and methods of &lt;code class="highlighter-rouge"&gt;pc_groups&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-final-report</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): Final report for GSoC 2019 (Week 12)</title>
      <pubDate>Sun, 18 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-final-report</link>
      <description>&lt;p&gt;It&amp;#8217;s finally the last week of the Google Summer of Code 2019. Before I start
discussing my work over the summer I would like to highlight my general
experience with the GSoC program.&lt;/p&gt;

&lt;p&gt;GSoC gives students all over the world the opportunity to connect and
collaborate with some of the best programmers involved in open source from
around the world. I found the programme tremendusly enriching both in terms of
the depth in which I got to explore some of the areas involved in my project
and also gave me exxposure to some areas I had no previous idea about.
The role of a mentor in GSoC is the most important and I consider myself
very lucky to have got Yathartha Anirudh Joshi and Amit Kumar as my mentors.
Amit and Yathartha has been tremendously encouraging and helpful throughout the summer.
I would also like to mention the importance of the entire community involved,
just being part of the SymPy community.&lt;/p&gt;

&lt;h3 id="work-completed"&gt;Work Completed&lt;/h3&gt;

&lt;p&gt;Here is a list of PRs which were opened during the span of GSoC:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16976"&gt;#16796 Added &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; for handling equations a - Mod(b, c) = 0 where only b is expr&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16890"&gt;#16890 Fixing lambert in bivariate to give all real solutions&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16960"&gt;#16960 (Don&amp;#8217;t Merge)(Prototype) Adding abs while converting equation to log form to get solved by &lt;code class="highlighter-rouge"&gt;_lambert&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17043"&gt;#17043 Feature power_list to return all powers of a variable present in f&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/17079"&gt;#17079 Defining ImageSet Union&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here is a list of PRs merged:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16976"&gt;#16796 Added &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; for handling equations a - Mod(b, c) = 0 where only b is expr&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href="https://github.com/sympy/sympy/pull/16890"&gt;#16890 Fixing lambert in bivariate to give all real solutions&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here is all the brief description about the PRs merged:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/16976"&gt;#16796 Added &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; for handling equations a - Mod(b, c) = 0 where only b is expr&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this PR a new solver &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; was made for solving modular equations.&lt;/p&gt;

&lt;h3 id="what-type-of-equations-to-be-considered-and-what-domain"&gt;What type of equations to be considered and what domain?&lt;/h3&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;A - Mod(B, C) = 0

    A -&amp;gt; This can or cannot be a function specifically(Linear, nth degree single
         Pow, a**f_x and Add and Mul) of symbol.(But currently its not a
        function of x)
    B -&amp;gt; This is surely a function of symbol.
    C -&amp;gt; It is an integer.
And domain should be a subset of S.Integers.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id="filtering-out-equations"&gt;Filtering out equations&lt;/h3&gt;
&lt;p&gt;A check is being applied named &lt;code class="highlighter-rouge"&gt;_is_modular&lt;/code&gt; which verifies that only above
mentioned type equation should return True.&lt;/p&gt;

&lt;h3 id="working-of-_solve_modular"&gt;Working of &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;In the starting of it there is a check if domain is a subset of Integers.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;domain.is_subset(S.Integers)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Only domain of integers and it subset are being considered while solving
these equations.
Now after this it separates out a modterm and the rest term on either
sides by this code.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;modterm = list(f.atoms(Mod))[0]
rhs = -(S.One)*(f.subs(modterm, S.Zero))
if f.as_coefficients_dict()[modterm].is_negative:
    # f.as_coefficient(modterm) was returning None don't know why
    # checks if coefficient of modterm is negative in main equation.
    rhs *= -(S.One)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now the equation is being inverted with the helper routine &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt;
like this.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;n = Dummy('n', integer=True)
f_x, g_n = _invert_modular(modterm, rhs, n, symbol)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I am defining n in &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; because &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt; contains
recursive calls to itself so if define the n there then it was going to have
many instances which of no use. Thats y I am defining it in &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now after the equation is inverted now solution finding takes place.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;if f_x is modterm and g_n is rhs:
        return unsolved_result
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;First of all if &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt; fails to invert then a ConditionSet is being
returned.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;    if f_x is symbol:
        if domain is not S.Integers:
            return domain.intersect(g_n)
        return g_n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And if &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt; is fully able to invert the equation then only domain
intersection needs to takes place. &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt; inverts the equation
considering S.Integers as its default domain.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;    if isinstance(g_n, ImageSet):
        lamda_expr = g_n.lamda.expr
        lamda_vars = g_n.lamda.variables
        base_set = g_n.base_set
        sol_set = _solveset(f_x - lamda_expr, symbol, S.Integers)
        if isinstance(sol_set, FiniteSet):
            tmp_sol = EmptySet()
            for sol in sol_set:
                tmp_sol += ImageSet(Lambda(lamda_vars, sol), base_set)
            sol_set = tmp_sol
        return domain.intersect(sol_set)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this case when g_n is an ImageSet of n and f_x is not symbol so the
equation is being solved by calling &lt;code class="highlighter-rouge"&gt;_solveset&lt;/code&gt; (this will not lead to
recursion because equation to be entered is free from Mod) and then
the domain intersection takes place.&lt;/p&gt;

&lt;h3 id="what-does-_invert_modular-do"&gt;What does &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt; do?&lt;/h3&gt;
&lt;p&gt;This function helps to convert the equation &lt;code class="highlighter-rouge"&gt;A - Mod(B, C) = 0&lt;/code&gt; to a
form (f_x, g_n).
First of all it checks the possible instances of invertible cases if not then
it returns the equation as it is.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;a, m = modterm.args
if not isinstance(a, (Dummy, Symbol, Add, Mul, Pow)):
        return modterm, rhs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now here is the check for complex arguments and returns the equation as it is
if somewhere it finds I.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;if rhs.is_real is False or any(term.is_real is False \
            for term in list(_term_factors(a))):
        # Check for complex arguments
        return modterm, rhs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now after this we check of emptyset as a solution by checking range of both
sides of equation.
As modterm can have values between [0, m - 1] and if rhs is out of this range
then emptySet is being returned.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;if (abs(rhs) - abs(m)).is_positive or (abs(rhs) - abs(m)) is S.Zero:
        # if rhs has value greater than value of m.
        return symbol, EmptySet()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now the equation haveing these types are being returned as the following&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;if a is symbol:
        return symbol, ImageSet(Lambda(n, m*n + rhs), S.Integers)

    if a.is_Add:
        # g + h = a
        g, h = a.as_independent(symbol)
        if g is not S.Zero:
            return _invert_modular(Mod(h, m), (rhs - Mod(g, m)) % m, n, symbol)

    if a.is_Mul:
        # g*h = a
        g, h = a.as_independent(symbol)
        if g is not S.One:
            return _invert_modular(Mod(h, m), (rhs*invert(g, m)) % m, n, symbol)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The more peculiar case is of &lt;code class="highlighter-rouge"&gt;a.is_Pow&lt;/code&gt; which is handled as following.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;if a.is_Pow:
        # base**expo = a
        base, expo = a.args
        if expo.has(symbol) and not base.has(symbol):
            # remainder -&amp;gt; solution independent of n of equation.
            # m, rhs are made coprime by dividing igcd(m, rhs)
            try:
                remainder = discrete_log(m / igcd(m, rhs), rhs, a.base)
            except ValueError: # log does not exist
                return modterm, rhs
            # period -&amp;gt; coefficient of n in the solution and also referred as
            # the least period of expo in which it is repeats itself.
            # (a**(totient(m)) - 1) divides m. Here is link of theoram:
            # (https://en.wikipedia.org/wiki/Euler's_theorem)
            period = totient(m)
            for p in divisors(period):
                # there might a lesser period exist than totient(m).
                if pow(a.base, p, m / igcd(m, a.base)) == 1:
                    period = p
                    break
            return expo, ImageSet(Lambda(n, period*n + remainder), S.Naturals0)
        elif base.has(symbol) and not expo.has(symbol):
            remainder_list = nthroot_mod(rhs, expo, m, all_roots=True)
            if remainder_list is None:
                return symbol, EmptySet()
            g_n = EmptySet()
            for rem in remainder_list:
                g_n += ImageSet(Lambda(n, m*n + rem), S.Integers)
            return base, g_n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Two cases are being created based of a.is_Pow&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;x**a&lt;/li&gt;
  &lt;li&gt;a**x&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;x**a -  It is being handled by the helper function &lt;code class="highlighter-rouge"&gt;nthroot_mod&lt;/code&gt; which returns
        required solution. I am not going into very mch detail for more
        information you can read the documentation of nthroot_mod.&lt;/p&gt;

&lt;p&gt;a**x - For this &lt;code class="highlighter-rouge"&gt;totient&lt;/code&gt; is being used in the picture whose meaning can be
       find on this &lt;a href="https://en.wikipedia.org/wiki/Euler's_theorem"&gt;Wikipedia&lt;/a&gt;
       page. And then its divisors are being checked to find the least period
       of solutions.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/16890"&gt;#16890 Fixing lambert in bivariate to give all real solutions&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This PR went through many up and downs and nearly made to the most commented PR.
And with the help of @smichr it was successfully merged. It mainly solved the
bug for not returning all solutions of lambert.&lt;/p&gt;

&lt;h2 id="explaining-the-function-_solve_lambert-main-function-to-solve-lambert-equations"&gt;Explaining the function &lt;code class="highlighter-rouge"&gt;_solve_lambert&lt;/code&gt; (main function to solve lambert equations)&lt;/h2&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;Input - f, symbol, gens
OutPut - Solution of f = 0 if its lambert type expression else NotImplementedError
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This function separates out cases as below based on the main function present in
the main equation.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;For the first ones:
1a1) B**B = R != 0 (when 0, there is only a solution if the base is 0,
                   but if it is, the exp is 0 and 0**0=1
                   comes back as B*log(B) = log(R)
1a2) B*(a + b*log(B))**p = R or with monomial expanded or with whole
                            thing expanded comes back unchanged
   log(B) + p*log(a + b*log(B)) = log(R)
   lhs is Mul:
       expand log of both sides to give:
       log(B) + log(log(B)) = log(log(R))
1b) d*log(a*B + b) + c*B = R
   lhs is Add:
       isolate c*B and expand log of both sides:
       log(c) + log(B) = log(R - d*log(a*B + b))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If the equation are of type 1a1, 1a2 and 1b then the mainlog of the equation is
taken into concern as the deciding factor lies in the main logarithmic term of equation.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;For the next two,
   collect on main exp
   2a) (b*B + c)*exp(d*B + g) = R
       lhs is mul:
           log to give
           log(b*B + c) + d*B = log(R) - g
   2b) -b*B + g*exp(d*B + h) = R
       lhs is add:
           add b*B
           log and rearrange
           log(R + b*B) - d*B = log(g) + h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If the equation are of type 2a and 2b then the mainexp of the equation is
taken into concern as the deciding factor lies in the main exponential term of equation.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;3) d*p**(a*B + b) + c*B = R
   collect on main pow
   log(R - c*B) - a*B*log(p) = log(d) + b*log(p)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If the equation are of type 3 then the mainpow of the equation is
taken into concern as the deciding factor lies in the main power term of equation.&lt;/p&gt;

&lt;p&gt;Eventually from all of the three cases the equation is meant to be converted to this form:-&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;f(x, a..f) = a*log(b*X + c) + d*X - f = 0 which has the
solution,  X = -c/b + (a/d)*W(d/(a*b)*exp(c*d/a/b)*exp(f/a)).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And the solution calculation process is done by &lt;code class="highlighter-rouge"&gt;_lambert&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Everything seems flawless?? You might be thinking no modification is required. Lets
see what loopholes are there in it.&lt;/p&gt;

&lt;h2 id="what-does-pr-16890-do"&gt;What does PR &lt;a href="https://github.com/sympy/sympy/pull/16890"&gt;#16890&lt;/a&gt; do?&lt;/h2&gt;

&lt;p&gt;There are basically two flaws present with the this approach.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Not considering all branches of equation while taking log both sides.&lt;/li&gt;
  &lt;li&gt;Calculation of roots should consider all roots in case having rational power.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="1-not-considering-all-branches-of-equation-while-taking-log-both-sides"&gt;1. Not considering all branches of equation while taking log both sides.&lt;/h3&gt;

&lt;p&gt;Let us consider this equation to be solved by &lt;code class="highlighter-rouge"&gt;_solve_lambert&lt;/code&gt; function.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;-1/x**2 + exp(x/2)/2 = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So what the old &lt;code class="highlighter-rouge"&gt;_solve_lambert&lt;/code&gt; do is to convert this equation to following.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;2*log(x) + x/2 = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and calculates its roots from &lt;code class="highlighter-rouge"&gt;_lambert&lt;/code&gt;.
But it missed this branch of equation while taking log on main equation.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;2*log(-x) + x/2 = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Yeah you can reproduce the original equation from this equation.So basically the problem
was that it missed the branches of equation while taking log. And when does the
main equation have more than one branch?? The terms having even powers of variable x
leads to two different branches of equation.&lt;/p&gt;

&lt;p&gt;So how it is solved?
What I has done is that before actually gets into solving I preprocess the main equation
and if it has more than one branches of equation while converting taking log then I consider
all the equations generated from them.(with the help of &lt;code class="highlighter-rouge"&gt;_solve_even_degree_expr&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;How I preprocess the equation?
So what I do is I replace all the even powers of x present with even powers of t(dummy variable).&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;Code for targeted replacement
lhs = lhs.replace(
            lambda i:  # find symbol**even
                i.is_Pow and i.base == symbol and i.exp.is_even,
            lambda i:  # replace t**even
                t**i.exp)
Example:-
Main equation -&amp;gt; -1/x**2 + exp(x/2)/2 = 0
After replacement -&amp;gt; -1/t**2 + exp(x/2)/2 = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now I take logarithms on both sides and simplify it.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;After simplifying -&amp;gt; 2*log(t) + x/2 = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now I call function &lt;code class="highlighter-rouge"&gt;_solve_even_degree_expr&lt;/code&gt; to replace the t with +/-x to generate two equations.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;Replacing t with +/-x
1. 2*log(x) + x/2 = 0
2. 2*log(-x) + x/2 = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And consider the solutions of both of the equations to return all lambert real solutions
of &lt;code class="highlighter-rouge"&gt;-1/x**2 + exp(x/2)/2 = 0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Hope you could understand the logic behind this work.&lt;/p&gt;

&lt;h3 id="2-calculation-of-roots-should-consider-all-roots-in-case-having-rational-power"&gt;2. Calculation of roots should consider all roots in case having rational power.&lt;/h3&gt;

&lt;p&gt;This flaw is in the calculation of roots in function &lt;code class="highlighter-rouge"&gt;_lambert&lt;/code&gt;.
Earlier the function_lambert has the working like :-&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find all the values of a, b, c, d, e in the required loagrithmic equation&lt;/li&gt;
  &lt;li&gt;Then it defines a solution of the form
    &lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;-c/b + (a/d)*l where l = LambertW(d/(a*b)*exp(c*d/a/b)*exp(-f/a), k)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;and then it included that solution.
I agree everything seems flawless here. but try to see the step where we are defining l.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let us suppose a hypothetical algorithm just like algorithm used in &lt;code class="highlighter-rouge"&gt;_lambert&lt;/code&gt;
in which equation to be solved is&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;x**3 - 1 = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and in which we define solution of the form&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;x = exp(I*2*pi/n) where n is the power of x in equation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;so the algorithm will give solution&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;x = exp(I*2*pi/3) # but expected was [1, exp(I*2*pi/3), exp(-I*2*pi/3)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;which can be found by finding all solutions of&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;x**n - exp(2*I*pi) = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;by a different correct algorithm. Thats y it was wrong.
The above algorithm would have given correct values for &lt;code class="highlighter-rouge"&gt;x - 1 = 0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And the question in your mind may arise that why only exp() because the
possiblity of having more than one roots is in exp(), because if the algorithm
would have been like &lt;code class="highlighter-rouge"&gt;x = a&lt;/code&gt;, where a is some real constant then there is not
any possiblity of further roots rather than solution like &lt;code class="highlighter-rouge"&gt;x = a**(1/n)&lt;/code&gt;.
And its been done in code like this:&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;code
num, den = ((c*d-b*f)/a/b).as_numer_denom()
p, den = den.as_coeff_Mul()
e = exp(num/den)
t = Dummy('t')
args = [d/(a*b)*t for t in roots(t**p - e, t).keys()]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id="work-under-development"&gt;Work under development&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/17079"&gt;#17079 Defining ImageSet Union&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This PR tends to define a unifying algorithm for linear relations.&lt;/p&gt;

&lt;h3 id="future-work"&gt;Future Work&lt;/h3&gt;
&lt;p&gt;Here is a list that comprises of all the ideas (which were a part of my GSoC
Proposal and/or thought over during the SoC) which can extend my GSoC project.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Integrating helper solvers within solveset: linsolve, solve_decomposition, nonlinsolve&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Handle nested trigonometric equations.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=105</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-11- Heading to the final week</title>
      <pubDate>Tue, 13 Aug 2019 17:26:54 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/08/13/gsoc19-week-11-heading-to-the-final-week/</link>
      <description>&lt;p&gt;With the end of this week the &lt;strong&gt;draw()&lt;/strong&gt; function has been completely implemented. The work on &lt;a href="https://github.com/sympy/sympy/pull/17345"&gt;PR #17345&lt;/a&gt; has been completed along with the documentations.&lt;/p&gt;



&lt;p&gt;As mentioned in the previous blog this PR was an attempt to make the &lt;strong&gt;draw()&lt;/strong&gt; function use SymPy&amp;#8217;s own plot() rather than importing matplotlib externally to plot the diagram. The idea was to plot the load equation which is in terms of singularity function. This would directly plot uniformly distributed load, uniformly varying load and other higher order loads except for point loads and moment loads.&lt;br /&gt; The task was now to plot the remaining parts of the diagram which were:&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;A rectangle for drawing the beam&lt;/li&gt;&lt;li&gt;Arrows for point loads&lt;/li&gt;&lt;li&gt;Markers for moment loads and supports &lt;/li&gt;&lt;li&gt;Colour filling to fill colour in inside the higher order loads (order &amp;gt;=0).&lt;span id="more-105"&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Instead of making temporary hacks to implement these, I went a step further to give the plotting module some additional functionalities. Apart from helping in implementing the &lt;strong&gt;draw()&lt;/strong&gt; function, &amp;nbsp;this would also enhance the plotting module.&lt;/p&gt;



&lt;p&gt;The basic idea was to have some additional keyworded arguments in the &lt;strong&gt;plot()&lt;/strong&gt; function. Every keyworded argument would be a list of dictionaries where each dictionary would represent the arguments (or parameters) that would have been passed in the corresponding matplotlib functions.&lt;/p&gt;



&lt;p&gt;These are the functions of matplotlib that can now be accessed using &lt;strong&gt;sympy&amp;#8217;s plot()&lt;/strong&gt;, along with where there are used in our current situation:&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;&lt;a href="https://matplotlib.org/api/_as_gen/matplotlib.patches.Rectangle.html"&gt;matplotlib.patches.Rectangle&lt;/a&gt;&amp;nbsp;-to draw the beam&lt;/li&gt;&lt;li&gt;&lt;a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.annotate.html"&gt;matplotlib.pyplot.annotate&lt;/a&gt;&amp;nbsp;&amp;#8211; to draw arrows of load&lt;/li&gt;&lt;li&gt;&lt;a href="https://matplotlib.org/3.1.1/api/markers_api.html"&gt;matplotlib.markers&lt;/a&gt;&amp;#8211; to draw supports and moment loads&lt;/li&gt;&lt;li&gt;&lt;a href="https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.fill_between.html"&gt;fill_between()&lt;/a&gt; &amp;#8211; to fill an area with color&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Another thing which is worth mentioning is that to use &lt;strong&gt;fill_between() &lt;/strong&gt;we would require numpy&amp;#8217;s &lt;strong&gt;arange()&lt;/strong&gt; for sure. Although it might be better if we could avoid using an external module directly, but I guess this is unavoidable for now. &lt;/p&gt;



&lt;p&gt;Also, I have added an option for the user to scale the plot and get a pictorial view of it in case where the plotting with the exact dimensions doesn&amp;#8217;t produce a decent diagram. For eg. If the magnitude of the load (order &amp;gt;= 0) is relatively higher to other applied loads or to the length of the beam, the load plot might get out of the final plot window. &lt;/p&gt;



&lt;p&gt;Here is an example:&lt;/p&gt;


&lt;pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"&gt;
&amp;gt;&amp;gt;&amp;gt; R1, R2 = symbols('R1, R2')
&amp;gt;&amp;gt;&amp;gt; E, I = symbols('E, I')

&amp;gt;&amp;gt;&amp;gt; b1 = Beam(50, 20, 30)

&amp;gt;&amp;gt;&amp;gt; b1.apply_load(10, 2, -1)
&amp;gt;&amp;gt;&amp;gt; b1.apply_load(R1, 10, -1)
&amp;gt;&amp;gt;&amp;gt; b1.apply_load(R2, 30, -1)
&amp;gt;&amp;gt;&amp;gt; b1.apply_load(90, 5, 0, 23)
&amp;gt;&amp;gt;&amp;gt; b1.apply_load(10, 30, 1, 50)
&amp;gt;&amp;gt;&amp;gt; b1.apply_support(50, "pin")
&amp;gt;&amp;gt;&amp;gt; b1.apply_support(0, "fixed")
&amp;gt;&amp;gt;&amp;gt; b1.apply_support(20, "roller")
# case 1 on the left
&amp;gt;&amp;gt;&amp;gt; p = b1.draw()
&amp;gt;&amp;gt;&amp;gt; p.show()

# case 2 on the right
&amp;gt;&amp;gt;&amp;gt; p1 = b1.draw(pictorial=True)
&amp;gt;&amp;gt;&amp;gt; p1.show()
&lt;/pre&gt;



&lt;figure class="wp-block-image size-large"&gt;&lt;img alt="" class="wp-image-107" src="https://ishanaj.files.wordpress.com/2019/08/screenshot-10-08-2019-23_04_45.png" /&gt;&lt;/figure&gt;



&lt;h2&gt;&lt;strong&gt;Next Week:&lt;/strong&gt;&lt;/h2&gt;



&lt;ul&gt;&lt;li&gt;Getting leftover PR&amp;#8217;s merged&lt;/li&gt;&lt;li&gt;Initiating implementation of Truss class&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Will keep you updated!&lt;/p&gt;



&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_11</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 11 - Final touches</title>
      <pubDate>Tue, 13 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_11/</link>
      <description>&lt;p&gt;So, the second last week of the project is over and we have decided to improve on the work we have done so far in the last few days. Read below to know more.&lt;/p&gt;

&lt;p&gt;In this week, I worked on, &lt;a href="https://github.com/sympy/sympy/pull/17146"&gt;#17146&lt;/a&gt; concered with symbolic &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;, &lt;a href="https://github.com/sympy/sympy/pull/17387"&gt;#17387&lt;/a&gt; related to assumptions of dependence among random variables, &lt;a href="https://github.com/sympy/sympy/pull/17336"&gt;#17336&lt;/a&gt; which fixed the bug in &lt;code class="highlighter-rouge"&gt;Q.hermitian&lt;/code&gt; the one I told you about in my previous post, and &lt;a href="https://github.com/sympy/sympy/pull/17306"&gt;#17306&lt;/a&gt;, implementing the matrices with random expressions.&lt;/p&gt;

&lt;p&gt;In fact, the last two PRs are merged. Now, coming on to symbolic &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;, I have completed the testing of all the methods except &lt;code class="highlighter-rouge"&gt;slicing&lt;/code&gt; feature of &lt;code class="highlighter-rouge"&gt;__getitem__&lt;/code&gt;, which I will do in this week. Regarding, the bug in &lt;code class="highlighter-rouge"&gt;Q.hermitian&lt;/code&gt;, well, my code at first, was giving incorrect results due to overriding problems in the logic. Francesco, helped me correct them and it&amp;#8217;s finally in. The major part of the week was devoted to assumptions of dependence. I did some study from Wikipedia, and implemented the class &lt;code class="highlighter-rouge"&gt;DependentPSpace&lt;/code&gt;. I have kept the class static because it will handle queries of the type, &lt;code class="highlighter-rouge"&gt;density(X + Y, Eq(Covariance(X, Y), S(1)/2)&lt;/code&gt; which from my point of view doesn&amp;#8217;t require creation of a probability space object.&lt;/p&gt;

&lt;p&gt;Coming on to the plan for the last week, we have decided that no new PRs will be opened and focus will be towards completing the already open PRs, so that we have most of our work completed. Francesco has also suggested to test the newly introduced classes with the ones of Wolfram Alpha, so that there are no inconsistencies.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://shubhamjha.com/2019/08/13/GSoC-Week-10-and-11</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 10 and 11</title>
      <pubDate>Tue, 13 Aug 2019 00:00:00 GMT</pubDate>
      <link>http://shubhamjha.com/2019/08/13/GSoC-Week-10-and-11.html</link>
      <description>&lt;p&gt;So, the second last week of the official coding period is over now. During the last two weeks, I was mostly occupied with on-campus placement drives, hence I couldn&amp;#8217;t put up a blog earlier. A summary of my work during these weeks is as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;First of all, &lt;a href="https://github.com/sympy/sympy/pull/17144"&gt;#17144&lt;/a&gt; is merged &amp;#128516;. This was a large PR and hence took time to get fully reviewed. With this, the performance of New assumptions comes closer to that of the old system. Currently, queries are evaluated about &lt;strong&gt;20X&lt;/strong&gt; faster than before.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/17379"&gt;#17379&lt;/a&gt; attempts to remove SymPy&amp;#8217;s costly &lt;strong&gt;rcall()&lt;/strong&gt; from the whole assumptions mechanism. It&amp;#8217;s a follow-up from &lt;a href="https://github.com/sympy/sympy/pull/17144"&gt;#17144&lt;/a&gt; and the performance gain is subtle for large queries. E.g.
    &lt;div class="language-py highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random_poly&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;positive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;positive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;In the master it takes &lt;code class="highlighter-rouge"&gt;4.292 s&lt;/code&gt;, out of this &lt;code class="highlighter-rouge"&gt;2.483 s&lt;/code&gt; is spent in &lt;strong&gt;rcall&lt;/strong&gt;. With this, the time spent is &lt;code class="highlighter-rouge"&gt;1.929 s&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;0.539 s&lt;/code&gt; respectively.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/sympy/sympy/pull/17392"&gt;#17392&lt;/a&gt; attempts to make the New Assumptions able to handle queries which involve Relationals. Currently, it works only with simple queries (e.g. &lt;code class="highlighter-rouge"&gt;ask(x&amp;gt;y, Q.positive(x) &amp;amp; Q.negative(y))&lt;/code&gt; now evaluates &lt;code class="highlighter-rouge"&gt;True&lt;/code&gt;) just like the way old system works. This is a much-awaited functionality for the new system. Also, during this I realized that sathandlers lack many necessary facts. This PR also adds many new facts to the system.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the last week of coding, my attempt would be to complete both of these PRs and get them merged. Also, I will try to add new facts to sathandlers.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-08-12-gsoc-week11/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 11 !!</title>
      <pubDate>Mon, 12 Aug 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-08-12-gsoc-week11/</link>
      <description>&lt;p&gt;Week 11 ends.. - 
          The second last week has also come to an end. We are almost there at the end of the ride. Me and Sartaj had a meeting on 13th of August about the final leftovers to be done, and wrapping up the GSoC work successfully. Here are the works which have...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-11</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 11</title>
      <pubDate>Sun, 11 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-11</link>
      <description>&lt;p&gt;This was the eleventh week meeting with the GSoC mentors which was scheduled on
Sunday 11th August, 2019 between 11:30 - 12:30 PM (IST). Me, Yathartha and Amit
were the attendees of the meeting. &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; was discussed in this meeting.&lt;/p&gt;

&lt;p&gt;Here is all the brief description about new solver &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; for solving
modular equations.&lt;/p&gt;
&lt;h3 id="what-type-of-equations-to-be-considered-and-what-domain"&gt;What type of equations to be considered and what domain?&lt;/h3&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;A - Mod(B, C) = 0

    A -&amp;gt; This can or cannot be a function specifically(Linear, nth degree single
         Pow, a**f_x and Add and Mul) of symbol.(But currently its not a
        function of x)
    B -&amp;gt; This is surely a function of symbol.
    C -&amp;gt; It is an integer.
And domain should be a subset of S.Integers.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id="filtering-out-equations"&gt;Filtering out equations&lt;/h3&gt;
&lt;p&gt;A check is being applied named &lt;code class="highlighter-rouge"&gt;_is_modular&lt;/code&gt; which verifies that only above
mentioned type equation should return True.&lt;/p&gt;

&lt;h3 id="working-of-_solve_modular"&gt;Working of &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;In the starting of it there is a check if domain is a subset of Integers.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;domain.is_subset(S.Integers)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Only domain of integers and it subset are being considered while solving
these equations.
Now after this it separates out a modterm and the rest term on either
sides by this code.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;modterm = list(f.atoms(Mod))[0]
rhs = -(S.One)*(f.subs(modterm, S.Zero))
if f.as_coefficients_dict()[modterm].is_negative:
    # f.as_coefficient(modterm) was returning None don't know why
    # checks if coefficient of modterm is negative in main equation.
    rhs *= -(S.One)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now the equation is being inverted with the helper routine &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt;
like this.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;n = Dummy('n', integer=True)
f_x, g_n = _invert_modular(modterm, rhs, n, symbol)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I am defining n in &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt; because &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt; contains
recursive calls to itself so if define the n there then it was going to have
many instances which of no use. Thats y I am defining it in &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now after the equation is inverted now solution finding takes place.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;if f_x is modterm and g_n is rhs:
        return unsolved_result
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;First of all if &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt; fails to invert then a ConditionSet is being
returned.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;    if f_x is symbol:
        if domain is not S.Integers:
            return domain.intersect(g_n)
        return g_n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And if &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt; is fully able to invert the equation then only domain
intersection needs to takes place. &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt; inverts the equation
considering S.Integers as its default domain.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;    if isinstance(g_n, ImageSet):
        lamda_expr = g_n.lamda.expr
        lamda_vars = g_n.lamda.variables
        base_set = g_n.base_set
        sol_set = _solveset(f_x - lamda_expr, symbol, S.Integers)
        if isinstance(sol_set, FiniteSet):
            tmp_sol = EmptySet()
            for sol in sol_set:
                tmp_sol += ImageSet(Lambda(lamda_vars, sol), base_set)
            sol_set = tmp_sol
        return domain.intersect(sol_set)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this case when g_n is an ImageSet of n and f_x is not symbol so the
equation is being solved by calling &lt;code class="highlighter-rouge"&gt;_solveset&lt;/code&gt; (this will not lead to
recursion because equation to be entered is free from Mod) and then
the domain intersection takes place.&lt;/p&gt;

&lt;h3 id="what-does-_invert_modular-do"&gt;What does &lt;code class="highlighter-rouge"&gt;_invert_modular&lt;/code&gt; do?&lt;/h3&gt;
&lt;p&gt;This function helps to convert the equation &lt;code class="highlighter-rouge"&gt;A - Mod(B, C) = 0&lt;/code&gt; to a
form (f_x, g_n).
First of all it checks the possible instances of invertible cases if not then
it returns the equation as it is.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;a, m = modterm.args
if not isinstance(a, (Dummy, Symbol, Add, Mul, Pow)):
        return modterm, rhs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now here is the check for complex arguments and returns the equation as it is
if somewhere it finds I.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;if rhs.is_real is False or any(term.is_real is False \
            for term in list(_term_factors(a))):
        # Check for complex arguments
        return modterm, rhs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now after this we check of emptyset as a solution by checking range of both
sides of equation.
As modterm can have values between [0, m - 1] and if rhs is out of this range
then emptySet is being returned.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;if (abs(rhs) - abs(m)).is_positive or (abs(rhs) - abs(m)) is S.Zero:
        # if rhs has value greater than value of m.
        return symbol, EmptySet()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now the equation haveing these types are being returned as the following&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;if a is symbol:
        return symbol, ImageSet(Lambda(n, m*n + rhs), S.Integers)

    if a.is_Add:
        # g + h = a
        g, h = a.as_independent(symbol)
        if g is not S.Zero:
            return _invert_modular(Mod(h, m), (rhs - Mod(g, m)) % m, n, symbol)

    if a.is_Mul:
        # g*h = a
        g, h = a.as_independent(symbol)
        if g is not S.One:
            return _invert_modular(Mod(h, m), (rhs*invert(g, m)) % m, n, symbol)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The more peculiar case is of &lt;code class="highlighter-rouge"&gt;a.is_Pow&lt;/code&gt; which is handled as following.&lt;/p&gt;
&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;if a.is_Pow:
        # base**expo = a
        base, expo = a.args
        if expo.has(symbol) and not base.has(symbol):
            # remainder -&amp;gt; solution independent of n of equation.
            # m, rhs are made coprime by dividing igcd(m, rhs)
            try:
                remainder = discrete_log(m / igcd(m, rhs), rhs, a.base)
            except ValueError: # log does not exist
                return modterm, rhs
            # period -&amp;gt; coefficient of n in the solution and also referred as
            # the least period of expo in which it is repeats itself.
            # (a**(totient(m)) - 1) divides m. Here is link of theoram:
            # (https://en.wikipedia.org/wiki/Euler's_theorem)
            period = totient(m)
            for p in divisors(period):
                # there might a lesser period exist than totient(m).
                if pow(a.base, p, m / igcd(m, a.base)) == 1:
                    period = p
                    break
            return expo, ImageSet(Lambda(n, period*n + remainder), S.Naturals0)
        elif base.has(symbol) and not expo.has(symbol):
            remainder_list = nthroot_mod(rhs, expo, m, all_roots=True)
            if remainder_list is None:
                return symbol, EmptySet()
            g_n = EmptySet()
            for rem in remainder_list:
                g_n += ImageSet(Lambda(n, m*n + rem), S.Integers)
            return base, g_n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Two cases are being created based of a.is_Pow&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;x**a&lt;/li&gt;
  &lt;li&gt;a**x&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;x**a -  It is being handled by the helper function &lt;code class="highlighter-rouge"&gt;nthroot_mod&lt;/code&gt; which returns
        required solution. I am not going into very mch detail for more
        information you can read the documentation of nthroot_mod.&lt;/p&gt;

&lt;p&gt;a**x - For this &lt;code class="highlighter-rouge"&gt;totient&lt;/code&gt; is being used in the picture whose meaning can be
       find on this &lt;a href="https://en.wikipedia.org/wiki/Euler's_theorem"&gt;Wikipedia&lt;/a&gt;
       page. And then its divisors are being checked to find the least period
       of solutions.&lt;/p&gt;

&lt;p&gt;Hope I am able to clear out everything!!&lt;/p&gt;

&lt;p&gt;Code improvement takes time!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=39</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] Week 10!</title>
      <pubDate>Sat, 10 Aug 2019 14:02:22 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/08/10/gsoc-2019-week-10/</link>
      <description>&lt;p&gt;A lot of modifications have been made to the PR &lt;a href="https://github.com/sympy/sympy/pull/17308"&gt;#17308&lt;/a&gt; so that the functionality can be well implemented and the code could be clean and efficient.&lt;/p&gt;



&lt;p&gt;The PR is merged to the master branch.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://anpandey.github.io/posts/sympy/2019-08-06-week-10.html</guid>
      <author>Ankit Pandey (anpandey)</author>
      <title>Ankit Pandey (anpandey): Google Summer of Code Week 10: Matrix Wildcard Redux</title>
      <pubDate>Tue, 06 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://anpandey.github.io/posts/sympy/2019-08-06-week-10.html</link>
      <description>&lt;p&gt;For this week, I&amp;#8217;ve made some more minor changes to the &lt;a href="https://github.com/sympy/sympy/pull/17299"&gt;&lt;code&gt;Indexed&lt;/code&gt; pull request&lt;/a&gt; from last week, in addition to filing a new &lt;a href="https://github.com/sympy/sympy/pull/17347"&gt;matrix wildcard pull request&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="matrix-wildcards-again"&gt;Matrix Wildcards (again)&lt;/h3&gt;
&lt;p&gt;Since &lt;a href="https://github.com/sympy/sympy/pull/17223"&gt;#17223&lt;/a&gt; was merged this week, I started with an implementation of matrix wildcards that takes advantage of the functionality included in the pull request. I thought that this would be relatively straightforward, with an implementation of the &lt;code&gt;matches&lt;/code&gt; method for the &lt;code&gt;MatrixWild&lt;/code&gt; subclass being enough. There was one problem though: the underlying matching implementation assumes that all powers in the expression are an instance of the &lt;code&gt;Pow&lt;/code&gt; class. However, this isn&amp;#8217;t true for matrix expressions: the &lt;code&gt;MatPow&lt;/code&gt; class, which represents matrix powers, is a subclass of its own. I&amp;#8217;m not exactly sure what the reason for this is, since a quick change of &lt;code&gt;MatPow&lt;/code&gt; to inherit from &lt;code&gt;Pow&lt;/code&gt; doesn&amp;#8217;t seem to break anything. I&amp;#8217;ll probably look into this a bit more, since I think this might have something to do with the fact that Matrix exponents can also include other matrices.&lt;/p&gt;
&lt;p&gt;My solution for this was to allow temporarily allow expansion of powers by recursing through the expression tree and setting the &lt;code&gt;is_Pow&lt;/code&gt; field of each matrix power to &lt;code&gt;True&lt;/code&gt; and later reverting these states later. It doesn&amp;#8217;t look pretty, but it does seem to work (you can see the code &lt;a href="https://github.com/sympy/sympy/blob/17fb5010e36e10de156dad032d2aea376051df24/sympy/matrices/expressions/matmul.py#L178-L197"&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;h2 id="next-steps"&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;ll try to get started with some optimizations that utilize this wildcard class once the pull request gets merged.&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_10</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 10 - Debugging, testing and Haar measure</title>
      <pubDate>Tue, 06 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_10/</link>
      <description>&lt;p&gt;This week was about a lot of debugging and testing. I also got to know some facts about random matrices and group theory.&lt;/p&gt;

&lt;p&gt;With the ending of 10th week, we have entered the second last week of the project. Well, this week was full of finding bugs, correcting and testing them. Mainly, I worked on, &lt;a href="https://github.com/sympy/sympy/pull/17146"&gt;#17146&lt;/a&gt;, &lt;a href="https://github.com/sympy/sympy/pull/17304"&gt;#17304&lt;/a&gt;, &lt;a href="https://github.com/sympy/sympy/pull/17336"&gt;#17336&lt;/a&gt; and &lt;a href="https://github.com/sympy/sympy/pull/17306"&gt;#17306&lt;/a&gt;. The first one was related to symbolic &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;, and it lacked systematic and robust tests. I pushed some commits to resolve the issue, though more is to be done. Now, coming to the second PR, it was related to circular ensembles. I got to know that distribution of these ensembles is something called Haar measure on &lt;code class="highlighter-rouge"&gt;U(n)&lt;/code&gt;, group of unitary matrices. I was not familiar with this. Thanks to &lt;a href="https://github.com/jksuom"&gt;jksuom&lt;/a&gt; for sharing some papers for the same. I will go through them in the following week. The third PR fixes a bug which was found while working on circular ensembles. Acutally, &lt;code class="highlighter-rouge"&gt;ask(Q.hermitian(Matrix([[2, 2 + I, 4], [2 - I, 3, I], [4, -I, 1]])))&lt;/code&gt; was giving &lt;code class="highlighter-rouge"&gt;False&lt;/code&gt;, however clearly the matrix is hermitian. So, I went ahead fixing it and waiting for reviews on my approach. The last one is related to matrices with random elements and it is complete after fixing a few bugs related to canonical outputs.&lt;/p&gt;

&lt;p&gt;What I learnt this week? 
Well, I learnt, &lt;strong&gt;When you think your work is complete, well, sorry to say, that&amp;#8217;s the beginning ;-)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Bye!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/08/week-10-the-finished-parser/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 10: The Finished Parser</title>
      <pubDate>Tue, 06 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/08/week-10-the-finished-parser/</link>
      <description>&lt;p&gt;&amp;#8220;Software is like entropy: It is difficult to grasp, weighs nothing, and obeys the Second Law of Thermodynamics; i.e., it always increases.&amp;#8221;  &amp;#8212; Norman Augustine
 Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and we will talk all about the Fortran Parser this week. I have passed the second evaluation and Fortran Parser pull request is complete.
 The Week Fortran Parser SymPy Expression Travis Builds The C Parser The Meeting  The Week This week began with me working on the C parser to finalize that.</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=91</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-10- An alternative to the draw() function</title>
      <pubDate>Mon, 05 Aug 2019 17:58:18 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/08/05/gsoc19-week-10-an-alternative-to-the-draw-function/</link>
      <description>&lt;p&gt;This was
the end of the tenth week, and we have entered the final phase of the project.&lt;/p&gt;



&lt;p&gt;For the last phase we have Truss calculations to be implemented in the continuum_mechanics module. I had initiated a discussion regarding what needs to be done and how the implementation will move forward in an &lt;a href="https://github.com/sympy/sympy/issues/17302"&gt;issue #17302&lt;/a&gt;. We will have to analyse a bit more about making Truss calculations symbolic and what benefits one might get in solving it symbolically. We have some good packages to compare from like &lt;a href="https://anastruct.readthedocs.io/en/latest/?badge=latest"&gt;this&lt;/a&gt;. I guess a bit more discussion is needed before we go ahead with it. &lt;/p&gt;



&lt;p&gt;Besides this, I had worked on improving the &lt;strong&gt;draw()&lt;/strong&gt; function implemented in the previous week in &lt;a href="https://github.com/sympy/sympy/pull/17240"&gt;PR #17240&lt;/a&gt;. I modified it to use the &lt;strong&gt;_backend&lt;/strong&gt; attribute for plotting the beam diagram. This could have worked until &lt;span id="more-91"&gt;&lt;/span&gt;I realised that using the &lt;strong&gt;_backend&lt;/strong&gt; attribute doesn&amp;#8217;t really has affect the &lt;strong&gt;Plot object. &lt;/strong&gt;To understand the last statement, lets go to how &lt;strong&gt;sympy.plot() &lt;/strong&gt;works.&lt;/p&gt;



&lt;p&gt;In simple terms, the equations that we pass through the &lt;strong&gt;plot()&lt;/strong&gt; function as arguments are actually stored in&lt;strong&gt; _series&lt;/strong&gt; attribute. So we can indirectly say that the basic data of the plot is stored in this attribute. But using the &lt;strong&gt;_backend &lt;/strong&gt;attribute wouldn&amp;#8217;t alter &lt;strong&gt;_series &lt;/strong&gt;at all and if &lt;strong&gt;_series &lt;/strong&gt;remains empty at the start it would end up storing nothing. &lt;/p&gt;



&lt;p&gt;But we are of course getting a decent plot at the end, so shouldn&amp;#8217;t we probably ignore this? No, it would surely  give the plot but we won&amp;#8217;t be getting a fully defined&lt;strong&gt; Plot &lt;/strong&gt;object which we can further use with &lt;strong&gt;PlotGrid&lt;/strong&gt; to get a subplot which includes all the five plots related to the beam.&lt;/p&gt;



&lt;p&gt;Keeping this in mind, I tried an alternative way to directly use&lt;strong&gt; sympy.plot() &lt;/strong&gt;&amp;nbsp;to give the plot. Although a bit hard and time taking to do, I have intiated this in a draft &lt;a href="https://github.com/sympy/sympy/pull/17345"&gt;PR #17345&lt;/a&gt;. This PR perfectly plots a rectangular beam and loads (except point and moment loads). Only things that are left here are to plot supports and arrows denoting the direction of the load.&lt;/p&gt;



&lt;p&gt;The example below shows how it functions: (keep in mind it just plots the basic structure of the intended beam diagram, it hasn&amp;#8217;t been completed yet)&lt;/p&gt;



&lt;div class="wp-block-group"&gt;&lt;div class="wp-block-group__inner-container"&gt;&lt;pre class="brush: python; collapse: false; title: ; wrap-lines: false; notranslate"&gt;
&amp;gt;&amp;gt;&amp;gt; E, I = symbols('E, I')
&amp;gt;&amp;gt;&amp;gt; b = Beam(9, E, I)
&amp;gt;&amp;gt;&amp;gt; b.apply_load(-12, 9, -1)  # gets skipped
&amp;gt;&amp;gt;&amp;gt; b.apply_load(50, 5, -2)  # gets skipped
&amp;gt;&amp;gt;&amp;gt; b.apply_load(3, 6, 1, end=8)
&amp;gt;&amp;gt;&amp;gt; b.apply_load(4, 0, 0, end=5)
&amp;gt;&amp;gt;&amp;gt; b.draw()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;



&lt;figure class="wp-block-image size-large is-resized"&gt;&lt;img alt="" class="wp-image-92" height="351" src="https://ishanaj.files.wordpress.com/2019/08/screenshot-05-08-2019-19_49_21.png" width="449" /&gt;&lt;/figure&gt;



&lt;p&gt;I also tried to complete the leftover PR&amp;#8217;s in this week, but still some work is left.&lt;/p&gt;



&lt;h2&gt;&lt;strong&gt;Next week:&lt;/strong&gt;&lt;/h2&gt;



&lt;ul&gt;&lt;li&gt;Completing the &lt;strong&gt;draw() &lt;/strong&gt;function&lt;/li&gt;&lt;li&gt;Documentation and testing&lt;/li&gt;&lt;li&gt;Starting Truss implementations&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Will keep you updated!&lt;/p&gt;



&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-08-05-gsoc-week10/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 10 !!</title>
      <pubDate>Mon, 05 Aug 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-08-05-gsoc-week10/</link>
      <description>&lt;p&gt;Week 10 ends.. - 
          Phase 3 of the GSoC coding period is traversong smoothly. !! I and Sartaj had a meeting on the 05th of August, about the timeline of the next 2 weeks. Here are the deliverables that have been completed in this week, including the minutes of the meeting. The second aseries...</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-10</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 10 - Induced Pcgs for polycyclic subgroups</title>
      <pubDate>Mon, 05 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-10</link>
      <description>&lt;p&gt;The tenth week of coding period has ended and a new PR&lt;a href="https://github.com/sympy/sympy/pull/17317"&gt;sympy/sympy#17317&lt;/a&gt; has been introduced. The PR implements induced Pcgs and exponent vector for polycyclic subgroups with respect to the original pcgs of the group.
Below is an example to show the functionality.&lt;/p&gt;

&lt;div class="highlighter-rouge"&gt;&lt;div class="highlight"&gt;&lt;pre class="highlight"&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from sympy.combinatorics import *
&amp;gt;&amp;gt;&amp;gt; S = SymmetricGroup(8)
&amp;gt;&amp;gt;&amp;gt; G = S.sylow_subgroup(2)
&amp;gt;&amp;gt;&amp;gt; gens = [G[0], G[1]]
&amp;gt;&amp;gt;&amp;gt; PcGroup = G.polycyclic_group()
&amp;gt;&amp;gt;&amp;gt; collector = PcGroup.collector
&amp;gt;&amp;gt;&amp;gt; ipcgs = collector.induced_pcgs(gens)
&amp;gt;&amp;gt;&amp;gt; [gen.order() for gen in ipcgs]
[2, 2, 2]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Further it can also be used to implement &lt;code class="highlighter-rouge"&gt;Canonical polycyclic sequence&lt;/code&gt; which can be used to check if two subgroups of polycyclic presented group &lt;code class="highlighter-rouge"&gt;G&lt;/code&gt; are equal or not.&lt;/p&gt;

&lt;p&gt;For the next week I&amp;#8217;ll try to complete the documentation work on polycyclic groups and open a PR for the same.&lt;/p&gt;

&lt;p&gt;Till then, good byee..&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://jmig5776.github.io//gsoc-week-10</guid>
      <author>Jogi Miglani (jmig5776)</author>
      <title>Jogi Miglani (jmig5776): GSoC 2019 - Week 10</title>
      <pubDate>Sun, 04 Aug 2019 00:00:00 GMT</pubDate>
      <link>https://jmig5776.github.io//gsoc-week-10</link>
      <description>&lt;p&gt;This was the tenth week meeting with the GSoC mentors which was scheduled on
Sunday 4th August, 2019 between 1:00 - 2:00 PM (IST). Me, Yathartha
were the attendees of the meeting.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Discussing previous week&amp;#8217;s progress&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Progress of &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt;:- In PR &lt;a href="https://github.com/sympy/sympy/pull/16976"&gt;#16976&lt;/a&gt;
After discussing with Yathartha, I decided to change the basic model of the &lt;code class="highlighter-rouge"&gt;_solve_modular &lt;/code&gt;
such that I should be able to target equations more efficiently and also the rest
of the types of equation should return ConditionSet. Cases like &lt;code class="highlighter-rouge"&gt;Mod(a**x, m) - rhs = 0&lt;/code&gt;
are special type and will be handled differently with the helper functions of ntheory module.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Progress of ImageSet Union:- In PR &lt;a href="https://github.com/sympy/sympy/pull/17079"&gt;#17079&lt;/a&gt;
This PR is currently been left for review.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Next week goals&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Work upon &lt;code class="highlighter-rouge"&gt;_solve_modular&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;In the following week I will be changing the domain of solving equations to
Integers only.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Code improvement takes time!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://www.kangzhiq.com/?p=36</guid>
      <author>Zhiqi KANG (kangzhiq)</author>
      <title>Zhiqi KANG (kangzhiq): [GSoC 2019] WEEK 9!</title>
      <pubDate>Sat, 03 Aug 2019 16:49:34 GMT</pubDate>
      <link>https://www.kangzhiq.com/2019/08/04/gsoc-2019-week-8-2/</link>
      <description>&lt;p&gt;I am so happy to pass the second evaluation!&lt;/p&gt;



&lt;p&gt;This week is dedicated to the implementation of new iteration functionalities in &lt;code&gt;Array&lt;/code&gt; module. Since the behaviour of &lt;code&gt;__getitem__&lt;/code&gt; is changed last week, we need to find a way to replace the old way of iterating arrays.&lt;/p&gt;



&lt;p&gt;For this purpose, a generator is implemented to enable the iteration over each element, which was the old way in SymPy to iterate the array. This functionality is equivalent to flattening the array and then visiting one by one these elements, so the new class is named as &lt;code&gt;Flatten&lt;/code&gt;. The advantage of generator will contribute to less memeory cose while iterating. This implementation corresponds as well the lazy-evaluation that I planned to implement in my proposal.&lt;/p&gt;



&lt;p&gt;So the implementation is in &lt;a href="https://github.com/sympy/sympy/pull/17308"&gt;#17308&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://arighnaiitg.github.io/2019-08-01-gsoc-week9/</guid>
      <author>Arighna Chakrabarty (arighnaiitg)</author>
      <title>Arighna Chakrabarty (arighnaiitg): GSoC Week 9 !!</title>
      <pubDate>Thu, 01 Aug 2019 07:00:00 GMT</pubDate>
      <link>https://arighnaiitg.github.io/2019-08-01-gsoc-week9/</link>
      <description>&lt;p&gt;Week 9 ends.. - 
          The last phase of this journey has started. I am happy to let you know that I have passed Phase 2 successfully. Phase 3 will include merging of some important code written in Phase 2, and also implementation of some other useful code. I had a meeting with Sartaj in...</description>
    </item>
    <item>
      <guid isPermaLink="false">http://shubhamjha.com/2019/07/31/GSoC-Week-9</guid>
      <author>Shubham Kumar Jha (ShubhamKJha)</author>
      <title>Shubham Kumar Jha (ShubhamKJha): GSoC 2019: Week 9</title>
      <pubDate>Wed, 31 Jul 2019 00:00:00 GMT</pubDate>
      <link>http://shubhamjha.com/2019/07/31/GSoC-Week-9.html</link>
      <description>&lt;p&gt;I spent most of this week getting &lt;a href="https://github.com/sympy/sympy/pull/17144"&gt;#17144&lt;/a&gt; ready to be merged. I had to change a lot of things from the last attempt. One of such was an attempt on &lt;strong&gt;early encoding&lt;/strong&gt;, I had tried it on &lt;strong&gt;Literals&lt;/strong&gt;. They were eventually going to be encoded so I tried to do this when &lt;strong&gt;Literals&lt;/strong&gt; were created only. But as Aaron suggested, my approach had left encodings in the global space and hence could leak memory. During the week, I tried to attach encoding to the &lt;strong&gt;CNF&lt;/strong&gt; object itself but it would have needed a lot of refactoring, since &lt;strong&gt;CNF&lt;/strong&gt; objects interacted with other such objects. So, after some attempts, at the end I left the encoding to be done at last in &lt;strong&gt;EncodedCNF&lt;/strong&gt; object. Currently, this is ready to be merged.&lt;/p&gt;

&lt;p&gt;For the coming weeks, I would try to improve over this.&lt;/p&gt;

&lt;p&gt;This was also the week for second monthly evaluation and I feel happy to announce that I passed it. From this week my college has also started but I am still able to give the required time to this project and complete it.&lt;/p&gt;

&lt;p&gt;Will keep you updated. Thank you !&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">http://ishanaj.wordpress.com/?p=74</guid>
      <author>Ishan Joshi (ishanaj)</author>
      <title>Ishan Joshi (ishanaj): GSoC&#x2019;19: Week-9- Analyzing the draw() function</title>
      <pubDate>Mon, 29 Jul 2019 05:43:20 GMT</pubDate>
      <link>https://ishanaj.wordpress.com/2019/07/29/gsoc19-week-9-analyzing-the-draw-function/</link>
      <description>&lt;p&gt;With the
end of this week the third phase officially ends. &lt;/p&gt;



&lt;p&gt;There has been some discussions in the &lt;a href="https://github.com/sympy/sympy/pull/17240"&gt;PR #17240&lt;/a&gt; which implements the &lt;strong&gt;draw() &lt;/strong&gt;function. We might change the name of the function to &lt;strong&gt;plot() &lt;/strong&gt;which is more consistent with the previous beam methods &lt;strong&gt;plot_shear_force()&lt;/strong&gt;, &lt;strong&gt;plot_bending_moment(), &lt;/strong&gt;etc.&lt;/p&gt;



&lt;p&gt;Another discussion was about making this beam diagram a part of the &lt;strong&gt;plot_loading_results(), &lt;/strong&gt;which basically intends to plot all the beam related plots. Although currently the beam diagram uses &lt;strong&gt;matplotlib &lt;/strong&gt;as an external module, whereas the &lt;strong&gt;plot_loading_results()&lt;/strong&gt; uses &lt;strong&gt;PlotGrid&lt;/strong&gt; which is Sympy&amp;#8217;s internal functionality. So it would be a bit tricky to merge those two.&lt;span id="more-74"&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;We also discussed the idea or rather the possibility of directly making use of SymPy&amp;#8217;s own plot to create a beam diagram. SymPy&amp;#8217;s &lt;strong&gt;plot() &lt;/strong&gt;is capable to plotting Singularity functions, so the load applied on the beam can also be plotted using &lt;strong&gt;sympy.plot() &lt;/strong&gt;as beam.load is indeed in terms of singularity function. But there is a problem when it comes to point loads and moment loads as the are in terms singularity function of negative order (or exponent). Not sure whether the sympy plot for singularity functions of negative order is plotted correctly, but the current plot won&amp;#8217;t help us in drawing point loads and moment loads. We might have to deal with it separately.&lt;/p&gt;



&lt;p&gt;I have
opened a discussion in the &lt;a href="https://groups.google.com/forum/?fromgroups#!topic/sympy/gmBNI-sffls"&gt;mailing
list&lt;/a&gt; regarding whether the plot is correct for singularity functions of negative
order, or what else should be done in order to get it corrected.&lt;/p&gt;



&lt;p&gt;Also, it will be difficult to plot a rectangle (for making beam) and markers (for making supports) via sympy.plot(). One idea is to go with the &lt;strong&gt;_backend&lt;/strong&gt; attribute of sympy.plot() which helps in directly using the &lt;strong&gt;backend &lt;/strong&gt;(i.e. matplotlib backend). I will have a look over it.&lt;/p&gt;



&lt;p&gt;Of
course if the beam diagram is made using SymPy&amp;#8217;s own plot it would surely be
preferred but for that we also need work on &lt;strong&gt;sympy.plot()&lt;/strong&gt; as currently it is limited to certain functionalities.&lt;/p&gt;



&lt;p&gt;From the
next week I will be starting with the last phase of implementing a Truss structure
and its respective calculations.&lt;/p&gt;



&lt;p&gt;Since only last few weeks are left, I think I will be able to make a draft PR for the last phase implementation by the end of the next week. And then we would only be left with minor things and leftovers of the previous phases.&lt;/p&gt;



&lt;p&gt;Also, I am glad to share that I was able to pass the second evaluations. So once again thank you mentors for all your support and guidance!&lt;/p&gt;



&lt;h2&gt;&lt;strong&gt;Next Week:&lt;/strong&gt;&lt;/h2&gt;



&lt;ul&gt;&lt;li&gt;Starting phase-IV&amp;nbsp; implementations&lt;/li&gt;&lt;li&gt;Simultaneously working and discussing previous
PR&amp;#8217;s.&lt;/li&gt;&lt;/ul&gt;



&lt;p&gt;Will
keep you updated!&lt;/p&gt;



&lt;p&gt;Thanks!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://czgdp1807.github.io/week_9</guid>
      <author>Gagandeep Singh (czgdp1807)</author>
      <title>Gagandeep Singh (czgdp1807): Week 9 - Lots of reviews</title>
      <pubDate>Mon, 29 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://czgdp1807.github.io/week_9/</link>
      <description>&lt;p&gt;This week I recieved a lot of reviews from the members of community on my various PRs and this has formed the base of the work for the next week. Let me share some of those reviews with you.&lt;/p&gt;

&lt;p&gt;As I told you that the PR &lt;a href="https://github.com/sympy/sympy/pull/17146"&gt;#17146&lt;/a&gt; was pending for reviews. Well, I received a lot of comments from &lt;a href="https://github.com/oscarbenjamin"&gt;@oscarbenjamin&lt;/a&gt; and &lt;a href="https://github.com/smichr"&gt;@smichr&lt;/a&gt; on pretty printing of symbolic &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;, the way tests are written, about &lt;code class="highlighter-rouge"&gt;inf&lt;/code&gt; and &lt;code class="highlighter-rouge"&gt;sup&lt;/code&gt; of &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;. This in turn helped me to discover bugs in other features of &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt;, like, &lt;code class="highlighter-rouge"&gt;reversed&lt;/code&gt;. In the following week, I will work on this stuff and will correct the things. Now moving on to the random matrices, i.e., the PR &lt;a href="https://github.com/sympy/sympy/pull/17174"&gt;#17174&lt;/a&gt; has been merged but more work is to be done for &lt;code class="highlighter-rouge"&gt;Matrix&lt;/code&gt; with entries as random variables. In fact, I studied about expressions of random matrices and summarised the results &lt;a href="https://github.com/sympy/sympy/pull/17174#issuecomment-514985333"&gt;here&lt;/a&gt;. Though the findings suggest specific algorithms for specific expressions like sum. I am still looking for a more generalized technique and will update you if found any.&lt;/p&gt;

&lt;p&gt;So, coming to the learning aspect. This week I learnt about the importance of exhaustive and systematic tests. The tests which I wrote for symbolic &lt;code class="highlighter-rouge"&gt;Range&lt;/code&gt; aren&amp;#8217;t so systematic and robust. I have found a way to improve them from &lt;a href="https://github.com/sympy/sympy/pull/17146#discussion_r307971324"&gt;this comment&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s all for now, signing off!!&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://divyanshu132.github.io//gsoc-week-9</guid>
      <author>Divyanshu Thakur (divyanshu132)</author>
      <title>Divyanshu Thakur (divyanshu132): GSoC 2019 - Week 9 - Merged Polycyclic groups</title>
      <pubDate>Mon, 29 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://divyanshu132.github.io//gsoc-week-9</link>
      <description>&lt;p&gt;Hello everyone, the ninth week of coding period has ended and there is a really good news the polycyclic group PR &lt;a href="https://github.com/sympy/sympy/pull/16991"&gt;sympy/sympy#16991&lt;/a&gt; that we were working from the last one and half months is finally merged. This week I didn&amp;#8217;t do that much work except organizing different methods and fixing small issues in the above pr to get it merged.&lt;/p&gt;

&lt;p&gt;There has been a lot of rearrangement of methods, where most of the methods were moved to the class &lt;code class="highlighter-rouge"&gt;Collector&lt;/code&gt; from the class &lt;code class="highlighter-rouge"&gt;PolycyclicGroup&lt;/code&gt;. Now, we do not need free symbols in-hand, they can be computed by the Collector if not provided by the user. There are few more things which are changed like relative order is computed in the course of polycyclic sequence and series computation. For better look one can go through the above Pr.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;m hopping to implement few things next week which are mentioned below.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Induced polycyclic sequence for a subgroup.&lt;/li&gt;
  &lt;li&gt;Get started with writing docs for polycyclic groups.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Till then, good byee..&lt;/p&gt;</description>
    </item>
    <item>
      <guid isPermaLink="false">https://sc0rpi0n101.github.io/2019/07/week-9-its-the-evaluation-week/</guid>
      <author>Nikhil Maan (Sc0rpi0n101)</author>
      <title>Nikhil Maan (Sc0rpi0n101): Week 9: It's the Evaluation Week!!</title>
      <pubDate>Sun, 28 Jul 2019 00:00:00 GMT</pubDate>
      <link>https://sc0rpi0n101.github.io/2019/07/week-9-its-the-evaluation-week/</link>
      <description>&lt;p&gt;Welcome everyone, this is your host Nikhil Maan aka Sc0rpi0n101 and this time we will be talking about the second evaluation for GSoC. The main objective of the week was to get the Fortran parser ready.
 The Fortran Parser Traivs and the Tests LFortran Evaluation!!! The meeting What Now  The Fortran Parser The Fortran parser is finally complete after shifting to using SymPy&amp;rsquo;s codegen AST. It can now parser all the stuff that the parser could do before shifting.</description>
    </item>
  </channel>
</rss>
